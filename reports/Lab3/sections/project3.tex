\subsection{Project \#3}
The goal of this project is to explore the UART transmission STATUS register behaviour in different scenarios.
\subsubsection{Scenario \#1}
In the first scenario, the aim is to send a single character through the transmission data register, as it can be seen in line 26 of the code in Listing \ref{lst:P31}, and then compare the STATUS register before and after the transmission, as illustrated in lines 19–20 and 28–29 in the code in the Listing \ref{lst:P31}.
\begin{minted}[linenos]{c}
#define BAUDRATE 2400
#define PARITY EVENPPARITY

int main() {
  char msg = 'f';

  volatile uint32_t *ptr_rx = (volatile uint32_t *)UART_0_RX_REG;
  volatile uint32_t *ptr_tx = (volatile uint32_t *)UART_0_TX_REG;
  volatile uint32_t *ptr_sts = (volatile uint32_t *)UART_0_ST_REG;
  volatile uint32_t *ptr_cnt = (volatile uint32_t *)UART_0_CNT_REG;
  volatile uint32_t *ptr_div = (volatile uint32_t *)UART_0_DIV_REG;

  // Configuration

  // Set baudrate
  *ptr_div |= (uint16_t)0x5160;

  // 1st point
  printf("Status before transmission: ");
  print_bin16((uint16_t)*ptr_sts);

  // wait trdy
  // while (((*ptr_sts) & (1 << 6)) == 0);

  // send msg
  *ptr_tx = (uint32_t)msg;

  printf("Status after transmission: ");
  print_bin16((uint16_t)*ptr_sts);

  return 0;
}
\end{minted}
\captionof{listing}{SCENARIO\_3\_1}
\label{lst:P31}~\\
The experiment's terminal output is the following:
\begin{listing}[ht]
\begin{minted}{text}
Status before transmission: 0000000111101000
Status after transmission: 0000000111001000
\end{minted}
\caption{Terminal output}
\label{lst:P31O}
\end{listing}~\\
The STATUS register illustrates the connection's current state through the use of flags.  
In the first sampling, the active flags are:
\begin{itemize}
    \item \textbf{ROE}: stands for "Receiver Overrun Error" and is active because in our code we never read the RECEIVER data register or reset our UART through the CONTROL register, so this error and the \textbf{E} flag are not cleared;
    \item \textbf{TMT}: stands for "Transmitter Empty", indicating that no transmission is in progress;
    \item \textbf{TRDY}: stands for "Transmitter Ready" and indicates that the transmission data register is empty, ready to be overwritten by a new byte;
    \item \textbf{RRDY}: stands for "Receiver Ready" and indicates that the receiver data register is empty, ready to be overwritten by a new byte;
    \item \textbf{E}: stands for "Error" and indicates a general error.
\end{itemize}
In the second sampling, the active flags are:
\begin{itemize}
    \item ROE;
    \item TRDY;
    \item RRDY;
    \item E.
\end{itemize}
It can be observed that the TRDY flag is no longer active after the character is written to the transmission data register in line 26 of the code (Listing \ref{lst:P31}).
Figure \ref{fig:P31OS} shows the transmission of the character via the UART.
By measuring the distance between two waveforms, the actual UART clock frequency can be determined. In our case:
\begin{equation}
    f_{clkUART} = \frac{1}{1 * \frac{2}{5} \cdot 10^{-3}} = 2500\, \text{Hz}
\end{equation}
It is slightly different from the effective one, which is 2400 Hz.
\subsubsection{Scenario \#2}
In the second scenario, the behaviour of the STATUS register during two consecutive transmissions is examined. To this end, the following code was written:
\begin{minted}[linenos]{c}
int main() {
  char msg = 'f';

  volatile uint32_t *ptr_rx = (volatile uint32_t *)UART_0_RX_REG;
  volatile uint32_t *ptr_tx = (volatile uint32_t *)UART_0_TX_REG;
  volatile uint32_t *ptr_sts = (volatile uint32_t *)UART_0_ST_REG;
  volatile uint32_t *ptr_cnt = (volatile uint32_t *)UART_0_CNT_REG;
  volatile uint32_t *ptr_div = (volatile uint32_t *)UART_0_DIV_REG;

  // Configuration

  // Set baudrate
  *ptr_div |= (uint16_t)0x5160;

  // ! USE OSCILLOSCOPE

  printf("Status before transmission: ");
  print_bin16((uint16_t)*ptr_sts);

  *ptr_tx = (uint32_t)(msg + 0);
  *ptr_tx = (uint32_t)(msg + 1);

  printf("Status after transmission: ");
  print_bin16((uint16_t)*ptr_sts);

  return 0;
}
\end{minted}
\captionof{listing}{SCENARIO\_3\_2}
\label{lst:P32}
In the code, we send two consecutive characters ("f" and "g" in lines 20–21) through the UART without waiting for the previous transmission to finish.\\
The output is:
\begin{listing}[ht]
\begin{minted}{text}
Status before transmission: 0000000111111100
Status after transmission: 0000000110011100
\end{minted}
\caption{Terminal output}
\label{lst:P32O}
\end{listing}
In the first sampling, the active flags are:
\begin{itemize}
    \item \textbf{BRK}: stands for "Break Detect" and takes care of the UART's reception. It appears because we neither read the receiver data register nor reset our UART through the CONTROL register;
    \item ROE;
    \item \textbf{TOE}: stands for "Transmitter Overrun Error" and appears because in our code we never reset our UART through the CONTROL register, so we overwrite our character in the transmission register;
    \item TMT;
    \item TRDY;
    \item RRDY;
    \item E.
\end{itemize}
While in the second sampling we have only these flags active:
\begin{itemize}
    \item BRK;
    \item ROE;
    \item TOE;
    \item RRDY;
    \item E.
\end{itemize}~\\
The same warnings as in code \ref{lst:P31} are present, with the addition of TOE and BRK, due to the lack of control and reset of the UART transmission in the code.
As a result, the second character overwrites the first one because it is transmitted too quickly and without checking the TRDY flag.
However, the oscilloscope image in Figure \ref{fig:P32OS} shows that the board successfully transmits the two characters; between them, only the parity bit of “f” and the start bit of “g” are observed.
\subsubsection{Scenario \#3}
In the last scenario, Scenario 2 is repeated, but three characters are transmitted instead of two (as shown in lines 20–21 of \ref{lst:P33}).
\begin{minted}[linenos]{c}
int main() {
  char msg = 'f';

  volatile uint32_t *ptr_rx = (volatile uint32_t *)UART_0_RX_REG;
  volatile uint32_t *ptr_tx = (volatile uint32_t *)UART_0_TX_REG;
  volatile uint32_t *ptr_sts = (volatile uint32_t *)UART_0_ST_REG;
  volatile uint32_t *ptr_cnt = (volatile uint32_t *)UART_0_CNT_REG;
  volatile uint32_t *ptr_div = (volatile uint32_t *)UART_0_DIV_REG;

  // Configuration

  // Set baudrate
  *ptr_div |= (uint16_t)0x5160;

  // ! USE OSCILLOSCOPE

  printf("Status before transmission: ");
  print_bin16((uint16_t)*ptr_sts);

  *ptr_tx = (uint32_t)(msg + 0);
  *ptr_tx = (uint32_t)(msg + 1);
  *ptr_tx = (uint32_t)(msg + 2);

  printf("Status after transmission: ");
  print_bin16((uint16_t)*ptr_sts);

  return 0;
}
\end{minted}
\captionof{listing}{SCENARIO\_3\_3}
\label{lst:P33}~\\
The terminal outputs the following data:
\begin{minted}{text}
Status before transmission: 0000000111111100
Status after transmission: 0000000110011100
\end{minted}
\captionof{listing}{Terminal output}
\label{lst:P33O}
We observe the same flag activations as in Scenario 2.  
However, by looking at the oscilloscope trace in Figure \ref{fig:P33OS}, we notice that the UART does not transmit the character "g" after "f", but instead sends "h".\\
This happens because the UART transmits only two characters: the first one ("f") and the last value written into the transmission register ("h"). The intermediate character ("g") is overwritten before the UART becomes ready to load a new byte. Since the code does not check the TRDY flag before writing to the transmission register, the second write occurs while the UART is still busy, causing the byte "g" to be lost.
